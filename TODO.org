+ [X] Arguments from C++. Lua style, ie stack based.

  (+ 1 2 3) becomes
  #+BEGIN_SRC C++
  pushValue(vm, value(1));
  pushValue(vm, value(2));
  pushValue(vm, value(3));
  getGlobal(vm, symbol(vm, "+"));
  call(vm, 3);
  #+END_SRC

+ [X] Convert parse tree into lists

+ [X] Pretty printing for lists

+ [X] Globals

+ [X] Move lambda from lexer to ast transformation

+ [X] Printing objects

+ [X] GC
  
  Works like a charm!

+ [X] Make the compiler compile function by function

  That is, dont parse the file then compile but parse a function,
  then compile it.
  This helps macros a LOT!
  Would also make mismatched parens crash, which is good
  bc right now we just get weird behavior.
  Need a generic parseExpr() that dispatch to different parse*()
  instead of just parseList(). parseExpr should fail on EOF

+ [X] better symbol interning
  
+ [X] REMOVE NEW

+ [X] Reuse temporary registers

+ [X] if
  
+ [X] scope (progn in CL)

+ [X] let

+ [X] set!
  
+ [X] Calling C++

+ [X] Globals
  + [X] Getting globals
  + [X] Setting globals
    #+BEGIN_SRC C++
    pushInt(vm, 23);
    setGlobal(vm, intern(vm, "foo"));
    #+END_SRC

+ [X] Lists, cons et. al.

+ [X] Macros
  
+ [X] quasiquote
  
  but kind of broken (quasiquote is hard!)

  
+ [X] make compileString not puke a bunch of debug logging when testing
  
+ [ ] intern keywords and make the ast builder use the inturned versions
  
+ [ ] Change strings from char * to struct String

+ [-] Objects

  + [X] Replace with one built on top of DynamicVector

    std::map sucks

  + [ ] Parent
    
  + [ ] Remove slot
    
    Needs care about removing objects that are present in parent.

    Maybe just make remove be set with undef? atleast if the key exists
    in the parent...

  + [ ] Array part?

    Maybe we should make vectors first class?

+ [ ] Replace DynamicVector

  std::vector sucks

+ [ ] multi-line printing of lists

+ [ ] string interning?

+ [X] quote.

  + [X] primitives


  + [X] lists

    prob. just a call to a C function.

  + [ ] objects

+ [X] quote et. al. abreviations

+ [ ] make-object sugar

+ [ ] get-object-slot

+ [ ] get-object-slot sugar

+ [ ] lambda sugar

  [args] -> lambda (args)

+ [ ] Closures

  Lua style upvalues will be used.
  WORKS!!!!
  + [ ] Make a CLOSE op, like lua

+ [ ] for, maybe as iterators?

+ [ ] Abstract char * into a stream for the parser.

  Might be a good place for "OOP"

+ [ ] Tune GC
  
+ [ ] Maybe switch to scheme define sugar?

+ [ ] Make it so that forward declarations of local
  functions are not needed
  
+ [ ] (if false 'blah) return garbage (should prob. be undef)