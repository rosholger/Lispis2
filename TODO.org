+ [X] Arguments from C++. Lua style, ie stack based.

  (+ 1 2 3) becomes
  #+BEGIN_SRC C++
  pushValue(vm, value(1));
  pushValue(vm, value(2));
  pushValue(vm, value(3));
  getGlobal(vm, symbol(vm, "+"));
  call(vm, 3);
  #+END_SRC

+ [X] Convert parse tree into lists

+ [X] Pretty printing for lists

+ [X] Globals

+ [X] Move lambda from lexer to ast transformation

+ [X] Printing objects

+ [X] GC
  
  Works like a charm!

+ [X] Make the compiler compile function by function

  That is, dont parse the file then compile but parse a function,
  then compile it.
  This helps macros a LOT!
  Would also make mismatched parens crash, which is good
  bc right now we just get weird behavior.
  Need a generic parseExpr() that dispatch to different parse*()
  instead of just parseList(). parseExpr should fail on EOF

+ [X] better symbol interning
  
+ [X] REMOVE NEW

+ [X] Reuse temporary registers

+ [X] if
  
+ [X] scope (progn in CL)

+ [X] let

+ [X] set!
  
+ [X] Calling C++

+ [X] Globals
  + [X] Getting globals
  + [X] Setting globals
    #+BEGIN_SRC C++
    pushInt(vm, 23);
    setGlobal(vm, intern(vm, "foo"));
    #+END_SRC

+ [X] Lists, cons et. al.

+ [X] Macros
  
+ [X] quasiquote
  
  but kind of broken (quasiquote is hard!)

  
+ [X] make compileString not puke a bunch of debug logging when testing
  
+ [ ] intern keywords and make the ast builder use the inturned versions
  
+ [ ] Change strings from char * to struct String

+ [-] Objects

  + [X] Replace with one built on top of DynamicVector

    std::map sucks

  + [ ] Parent
    
  + [ ] Remove slot
    
    Needs care about removing objects that are present in parent.

    Maybe just make remove be set with undef? atleast if the key exists
    in the parent...

  + [ ] Array part?

    Maybe we should make vectors first class?

+ [ ] Replace DynamicVector

  std::vector sucks

+ [ ] multi-line printing of lists

+ [ ] string interning?

+ [X] quote.

  + [X] primitives


  + [X] lists

    prob. just a call to a C function.

  + [\] objects
    We just quote everything, no fancy shit

+ [X] quote et. al. abreviations

+ [X] make-object sugar

+ [X] get-object-slot

+ [X] get-object-slot sugar

+ [-] Closures
  
  Lua style upvalues will be used.
  + [X] WORKS!!!!
  + [ ] Make a CLOSE op, like lua

+ [X] for, maybe as iterators?

+ [ ] Abstract char * into a stream for the parser.

  Might be a good place for "OOP"

+ [ ] Tune GC
  
+ [ ] Make GC grow the heap if we run out of memory
  
  mremap
  
+ [ ] Maybe switch to scheme define sugar?

+ [ ] Make it so that forward declarations of local
  functions are not needed
  
  Hard... would have to scan the function for let statements
  and add them as local variables before compiling the body.
  Would mean that

  #+BEGIN_SRC lisp
  (let a 1)
  (lambda ()
    (let b a)
    (let a 2))
  #+END_SRC
  
  Would be illegal, bc a would be a local variable without a value...
  I totally see why they chose the path they did with let.
  
+ [ ] (if false 'blah) return garbage (should prob. be undef)

+ [ ] switch?
  
  Not like CL case, more like switch in C++
  (might be faster than an if else chain)
  
+ [ ] possibly skip the parse stage and go straight to AST?

  We are generating insane amounts of garbage when parsing, this would
  lower it substantially.
  
  We would still need to be able to convert from sexp to AST
  bc of macros though. So the *ToAST functions are not a waste of time.
  
  
+ [ ] need a way to tell how many frames from the last C-call we are

  That is if we have the call-stack

  lispisFuncA

  lispisFuncB
  
  cFunc

  lispisFuncC

  (stack-depth) should return 2, not 3
  
+ [ ] Make C functions get their arguments in logical order

  This can be quite simple if we make register allocation
  for arglists start at the right hand instead of the left hand.
  That is if we have (a b . c) the c becomes r0, b r1 and a r2.
  We can still evaluation arguments left to right bc register machine.
  The only thing that gets kind of complicated is setting the arguments
  of lispis functions called from C.
  But the way it is now is broken anyway bc calling a
  lispis function with the arguments from a lispis functions
  puts them in reverse.
  