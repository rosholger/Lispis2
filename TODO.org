+ [X] Arguments from C++. Lua style, ie stack based.

  (+ 1 2 3) becomes
  #+BEGIN_SRC C++
  pushValue(vm, value(1));
  pushValue(vm, value(2));
  pushValue(vm, value(3));
  getGlobal(vm, symbol(vm, "+"));
  call(vm, 3);
  #+END_SRC

+ [X] Convert parse tree into lists

+ [X] Pretty printing for lists

+ [X] Globals

+ [X] Move lambda from lexer to ast transformation

+ [X] Printing objects

+ [X] GC
  
  Works like a charm!

+ [X] Make the compiler compile function by function

  That is, dont parse the file then compile but parse a function,
  then compile it.
  This helps macros a LOT!
  Would also make mismatched parens crash, which is good
  bc right now we just get weird behavior.
  Need a generic parseExpr() that dispatch to different parse*()
  instead of just parseList(). parseExpr should fail on EOF

+ [X] better symbol interning
  
+ [X] REMOVE NEW
  
+ [ ] intern keywords and make the ast builder use the inturned versions
  
+ [ ] Change strings from char * to struct String

+ [-] Objects

  + [X] Replace with one built on top of DynamicVector

    std::map sucks

  + [ ] Parent
    
  + [ ] Remove slot
    
    Needs care about removing objects that are present in parent.

    Maybe just make remove be set with undef? atleast if the key exists
    in the parent...

  + [ ] Array part?

    Maybe we should make vectors first class?

+ [ ] Replace DynamicVector

  std::vector sucks

+ [ ] multi-line printing of lists

+ [ ] string interning?

+ [X] quote.

  + [X] primitives


  + [ ] lists

    prob. just a call to a C function.

  + [ ] objects

+ [ ] quote et. al. abreviations

+ [ ] make-object sugar

+ [ ] get-object-slot

+ [ ] get-object-slot sugar

+ [ ] lambda sugar

  [args] -> lambda (args)

+ [-] Closures

  Lua style upvalues will be used.
  WORKS!!!!
  + [ ] Make a CLOSE op, like lua

+ [ ] Globals
  + [X] Getting globals
  + [ ] Setting globals
    #+BEGIN_SRC C++
    pushInt(vm, 23);
    setGlobal(vm, intern(vm, "foo"));
    #+END_SRC

+ [ ] Calling C++
  
+ [ ] Lists, cons et. al.

+ [ ] Macros

+ [ ] let

+ [ ] set!

+ [ ] if

+ [ ] for, maybe as iterators?

+ [ ] Abstract char * into a stream for the parser.

  Might be a good place for "OOP"

+ [ ] Tune GC
  
+ [ ] Basic register allocation

  Right now we dont reuse registers that are used for temporaries.
  This is a problem for the GC, since it means that functions keep
  all their temporaries alive.