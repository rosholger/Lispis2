(defmacro : (obj key)
  `(get-slot ,obj ,(list 'quasiquote key)))
(defmacro :! (obj key value)
  `(set-slot ,obj ,(list 'quasiquote key) ,value))
(defmacro ! (obj func . args)
  (append (list (list ': obj func) obj) args))
(defmacro range (s e)
  `{(start ,s) (end ,e) (step 1) (curr 0) (alive true)
    (update (lambda (this)
              (let ret (: this curr))
              (if (: this alive)
                  (scope
                   (:! this curr (+ (: this curr) (: this step)))
                   (if (> ret (: this end))
                       (:! this alive false))))
              ret))})
(defmacro assert (pred? . args)
  `(if ,pred?
       true
       (error ,@args)))
(define list-iterator (lst)
  {(curr lst) (alive (not (null? lst)))
   (update (lambda (this)
             (let ret '())
             (if (: this alive)
                 (scope
                  (set! ret (car (: this curr)))
                  (:! this curr (cdr (: this curr)))
                  (if (null? (: this curr))
                      (:! this alive false))))
             ret))})
(define map (proc lst)
  (let ret '())
  (let curr '())
  (for (elem (list-iterator lst))
       (if (null? ret)
           (scope
            (set! ret (cons (proc elem) ret))
            (set! curr ret))
           (scope
            (set-cdr! curr (cons (proc elem) '()))
            (set! curr (cdr curr)))))
  ret)
(define foldl (proc init lst)
  (let ret init)
  (for (elem (list-iterator lst))
       (set! ret (proc elem ret)))
  ret)
(define foldr (proc init lst)
  (if (null? lst)
      init
      (proc (car lst) (foldr proc init (cdr lst)))))
(println (map (lambda (a) (+ a 1)) '(1 2 3 4 5 6)))
(println (foldl cons '() '(a b c d e)))
(println (foldr cons '() '(a b c d e)))
;(define)