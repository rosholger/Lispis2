* Done
+ Arguments from C++. Lua style, ie stack based.
  (+ 1 2 3) becomes
  pushValue(vm, value(1));
  pushValue(vm, value(2));
  pushValue(vm, value(3));
  getGlobal(vm, symbol(vm, "+"));
  call(vm, 3);
+ Objects
  Do this before closures, bc closures will use them.
  I.E. symbol to symbol... Or maybe not?
  Should prob be symbol to ASTVariable instead
+ quote.
  + primitives
+ Convert parse tree into lists
+ Pretty printing for lists
+ Globals
  
* Todo
- Make the compiler compile function by function
  That is, dont parse the file then compile but parse a function,
  then compile it.
  This helps macros a LOT!
  Would also make mismatched parens crash, which is good
  bc right now we just get weird behavior.
  Need a generic parseExpr() that dispatch to different parse*()
  instead of just parseList(). parseExpr should fail on EOF
- Abstract char * into a stream for the parser.
  Might be a good place for OOP
- Objects
  - Replace with one built on top of DynamicVector
    map sucks
  - Parent
  - Array part
- Replace DynamicVector
  std::vector sucks
- multi-line printing of lists
- Printing objects
- (better) string interning
  Will need hashing
- quote.
  - lists
    prob. just a call to a C function.
  - objects
- Move lambda from lexer to ast transformation
- quote et. al. abreviations
- make-object sugar
- get-object-slot
- lambda sugar
  [args] -> lambda (args)
- Closures
  Lua style upvalues will be used.
- Globals
- Calling C++
- Lists, cons et. al.
- Macros
- let
- set!
- if
- for, maybe as iterators?